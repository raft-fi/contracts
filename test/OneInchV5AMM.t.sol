// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import { OneInchV5AMM } from "../contracts/AMMs/OneInchV5AMM.sol";
import { Test } from "forge-std/Test.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// solhint-disable max-line-length
contract OneInchV5AMMIntegrationTest is Test {
    address public constant AGGREGATION_ROUTER_V5 = 0x1111111254EEB25477B68fb85Ed929f73A960582;
    address public constant WHALE = 0xA9D1e08C7793af67e9d92fe308d5697FB81d3E43;

    OneInchV5AMM public oneInchV5AMM;

    function setUp() public {
        vm.createSelectFork("mainnet", 17_216_180);
        oneInchV5AMM = new OneInchV5AMM(AGGREGATION_ROUTER_V5);
    }

    function testOneInch_swap() public {
        IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        IERC20 stETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);
        uint256 swapAmount = 42_069e6;
        uint256 minReturn = 20e18;

        uint256 usdcBalBefore = usdc.balanceOf(WHALE);
        uint256 stETHBalBefore = stETH.balanceOf(WHALE);

        vm.startPrank(WHALE);
        usdc.approve(address(oneInchV5AMM), swapAmount);

        // Note: the expected OneInchV5Amm address (0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f) was hardcoded
        // into the swapCallData! Issues may arise if the OneInchV5AMM address is changed.
        bytes memory swapCalldata =
            hex"12aa3caf0000000000000000000000001136b25047e142fa3018184793aec68fbb173ce4000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe840000000000000000000000001136b25047e142fa3018184793aec68fbb173ce40000000000000000000000005615deb798bb3e4dfa0139dfa1b3d433cc23b72f00000000000000000000000000000000000000000000000000000009cb81ff400000000000000000000000000000000000000000000000012908eb64a2d198a10000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000019900000000000000000000000000000000000000000000017b00014d00010300a007e5c0d20000000000000000000000000000000000000000df0000c500008b00004f02a00000000000000000000000000000000000000000000000012908eb64a2d198a3ee63c1e50188e6a0c2ddd26feeb64f039a2c41296fcb3f5640a0b86991c6218b36c1d19d4a2e9eb0ce3606eb484101c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200042e1a7d4d00000000000000000000000000000000000000000000000000000000000000004060ae7ab96520de3a18e5e111b5eaab095312d7fe84a1903eab00000000000000000000000042f527f50f16a103b6ccab48bccca214500c10210020d6bdbf78ae7ab96520de3a18e5e111b5eaab095312d7fe8400a0f2fa6b66ae7ab96520de3a18e5e111b5eaab095312d7fe8400000000000000000000000000000000000000000000000138ab12bac655e4080000000000000000000999e7f52529f580a06c4eca27ae7ab96520de3a18e5e111b5eaab095312d7fe841111111254eeb25477b68fb85ed929f73a960582000000000000008c4b600c";
        bytes memory extraData = abi.encode(0, swapCalldata);

        uint256 amountOut = oneInchV5AMM.swap(usdc, stETH, swapAmount, minReturn, extraData);

        assertEq(usdcBalBefore - usdc.balanceOf(WHALE), swapAmount);
        assertEq(amountOut, stETH.balanceOf(WHALE) - stETHBalBefore);
        assertGe(amountOut, minReturn);
    }

    function testOneInch_swap_offsetSwapAmount() public {
        IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        IERC20 stETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);
        uint256 swapAmount = 42_069e6 + 100e6;
        uint256 minReturn = 20e18;

        uint256 usdcBalBefore = usdc.balanceOf(WHALE);
        uint256 stETHBalBefore = stETH.balanceOf(WHALE);

        vm.startPrank(WHALE);
        usdc.approve(address(oneInchV5AMM), swapAmount);

        // Note: the expected OneInchV5Amm address (0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f) was hardcoded
        // into the swapCallData! Issues may arise if the OneInchV5AMM address is changed.
        bytes memory swapCalldata =
            hex"12aa3caf0000000000000000000000001136b25047e142fa3018184793aec68fbb173ce4000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe840000000000000000000000001136b25047e142fa3018184793aec68fbb173ce40000000000000000000000005615deb798bb3e4dfa0139dfa1b3d433cc23b72f00000000000000000000000000000000000000000000000000000009cb81ff400000000000000000000000000000000000000000000000012908eb64a2d198a10000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000019900000000000000000000000000000000000000000000017b00014d00010300a007e5c0d20000000000000000000000000000000000000000df0000c500008b00004f02a00000000000000000000000000000000000000000000000012908eb64a2d198a3ee63c1e50188e6a0c2ddd26feeb64f039a2c41296fcb3f5640a0b86991c6218b36c1d19d4a2e9eb0ce3606eb484101c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200042e1a7d4d00000000000000000000000000000000000000000000000000000000000000004060ae7ab96520de3a18e5e111b5eaab095312d7fe84a1903eab00000000000000000000000042f527f50f16a103b6ccab48bccca214500c10210020d6bdbf78ae7ab96520de3a18e5e111b5eaab095312d7fe8400a0f2fa6b66ae7ab96520de3a18e5e111b5eaab095312d7fe8400000000000000000000000000000000000000000000000138ab12bac655e4080000000000000000000999e7f52529f580a06c4eca27ae7ab96520de3a18e5e111b5eaab095312d7fe841111111254eeb25477b68fb85ed929f73a960582000000000000008c4b600c";
        uint256 fromAmountOffset = 164;
        bytes memory extraData = abi.encode(fromAmountOffset, swapCalldata);

        uint256 amountOut = oneInchV5AMM.swap(usdc, stETH, swapAmount, minReturn, extraData);

        assertEq(usdcBalBefore - usdc.balanceOf(WHALE), swapAmount);
        assertEq(amountOut, stETH.balanceOf(WHALE) - stETHBalBefore);
        assertGe(amountOut, minReturn);
    }

    function testOneInch_unoswap() public {
        IERC20 crv = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);
        IERC20 aave = IERC20(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9);
        uint256 swapAmount = 42_069_000_000_000_000;
        uint256 minReturn = 1;

        uint256 crvBalBefore = crv.balanceOf(WHALE);
        uint256 aaveBalBefore = aave.balanceOf(WHALE);

        vm.startPrank(WHALE);
        crv.approve(address(oneInchV5AMM), swapAmount);

        bytes memory swapCalldata =
            hex"0502b1c5000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd5200000000000000000000000000000000000000000000000000957588590e50000000000000000000000000000000000000000000000000000001cf1675a728f10000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000280000000000000003b6d03404811c9384bc8447945806a2319159054b228fda780000000000000003b6d0340d75ea151a61d06868e31f8988d28dfe5e9df57b48c4b600c";
        bytes memory extraData = abi.encode(0, swapCalldata);

        uint256 amountOut = oneInchV5AMM.swap(crv, aave, swapAmount, minReturn, extraData);

        assertEq(crvBalBefore - crv.balanceOf(WHALE), swapAmount);
        assertEq(amountOut, aave.balanceOf(WHALE) - aaveBalBefore);
        assertGe(amountOut, minReturn);
    }

    function testOneInch_unoswap_offsetSwapAmount() public {
        IERC20 crv = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);
        IERC20 aave = IERC20(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9);
        uint256 swapAmount = 42_169_000_000_000_000;
        uint256 minReturn = 1;

        uint256 crvBalBefore = crv.balanceOf(WHALE);
        uint256 aaveBalBefore = aave.balanceOf(WHALE);

        vm.startPrank(WHALE);
        crv.approve(address(oneInchV5AMM), swapAmount);

        bytes memory swapCalldata =
            hex"0502b1c5000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd5200000000000000000000000000000000000000000000000000957588590e50000000000000000000000000000000000000000000000000000001cf1675a728f10000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000280000000000000003b6d03404811c9384bc8447945806a2319159054b228fda780000000000000003b6d0340d75ea151a61d06868e31f8988d28dfe5e9df57b48c4b600c";
        uint256 fromAmountOffset = 36;
        bytes memory extraData = abi.encode(fromAmountOffset, swapCalldata);

        uint256 amountOut = oneInchV5AMM.swap(crv, aave, swapAmount, minReturn, extraData);

        assertEq(crvBalBefore - crv.balanceOf(WHALE), swapAmount);
        assertEq(amountOut, aave.balanceOf(WHALE) - aaveBalBefore);
        assertGe(amountOut, minReturn);
    }
}
